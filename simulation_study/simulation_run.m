%{

This file is the main body of the simulation run. It should be called by
the "launcher.m" function.

Author: Tomas Rubin, tomas.rubin@gmail.com

Code developed on: MATLAB R2018a

%}


function simulation_run(initial_seed,simulated_process,response_process_shape,response_process,iCase) % XXX

addpath('../master')
addpath('../master/fdaM')

rng(initial_seed) % XXX
 
% initial_seed=-9999;
% simulated_process=1; % 0=iid, 1=AR(1,0.7), 4=MA(4)
% response_process_shape=2; % 1= identity, 2= sin (badly aligned), 4= sin, 4= exp
% response_process=1; % 1=(b_0,b_1),  2=(b_0,b_3),  3=slowly decay   all with sigma^2 = 0.1
% iCase = 7; % 1..15


holdout = 0.2; % set up the holdout parameter, the holdout partition is not used for fitting the cross-spectral density, it's used for error evaluation



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% prepare the CSV file for saving the results

fileName_tikhonov = 'results/sim_tikhonov.csv';
fileName_threshold_value = 'results/sim_threshold_value.csv';

%% create the columns

cHeader_tikhonov = {...
    'simulated_process',...
    'response_process_shape',...
    'response_process',...
    'iCase',...
    'seed',...
    'exec time'...
    'CV K-fold',...
    'T',...
    'num obs',...
    'avg obs per curve',...
    'bw_mu',...
    'bw_F',...
    'bw_v',...
    'specDensity q_bartlett',...
    'specCrossDensity q_bartlett',...
    'cut_of_lag',...
    'nRandi_max',...
    'sigma^2',...
    'sigma^2 estim loc lin',...
    'sigma^2 estim loc qv (used)',...
    'cov lag 0 MSE',...
    'cov lag 0 RMSE',...
    'spec density MSE - FRO',...
    'spec density RMSE - FRO',...
    'spec density R2MSE - FRO',...
    'spec density MSE - intmax',...
    'spec density RMSE - intmax',...
    'spec density R2MSE - intmax',...
    'spec density MSE - maxmax',...
    'spec density RMSE - maxmax',...
    'spec density - bias norm',...
    'spec cross density MSE - L2',...
    'spec cross density RMSE - L2',...
    'spec cross density MSE - intmax',...
    'spec cross density RMSE - intmax',...
    'dynamic krig MSE',...
    'dynamic krig RMSE',...
    'dynamic krig MSE (true dynamics)',...
    'dynamic krig RMSE (true dynamics)',...
    'transfer: tikhonov parameter',...
    'transfer: tikhonov parameter (rule)',...
    'transfer: RMSE',...
    'transfer: MSE',...
    'Z error train',...
    'Z error train (true dynamics)',...
    'Z error test',...
    'Z error test (true dynamics)',...
    'Z error train (holdout)',...
    'Z error train (holdout true dynamics)',...
    };
cHeader_threshold_value = {...
    'simulated_process',...
    'response_process_shape',...
    'response_process',...
    'iCase',...
    'seed',...
    'exec time'...
    'CV K-fold',...
    'T',...
    'num obs',...
    'avg obs per curve',...
    'bw_mu',...
    'bw_F',...
    'bw_v',...
    'specDensity q_bartlett',...
    'specCrossDensity q_bartlett',...
    'cut_of_lag',...
    'nRandi_max',...
    'sigma^2',...
    'sigma^2 estim loc lin',...
    'sigma^2 estim loc qv (used)',...
    'cov lag 0 MSE',...
    'cov lag 0 RMSE',...
    'spec density MSE - FRO',...
    'spec density RMSE - FRO',...
    'spec density R2MSE - FRO',...
    'spec density MSE - intmax',...
    'spec density RMSE - intmax',...
    'spec density R2MSE - intmax',...
    'spec density MSE - maxmax',...
    'spec density RMSE - maxmax',...
    'spec density - bias norm',...
    'spec cross density MSE - L2',...
    'spec cross density RMSE - L2',...
    'spec cross density MSE - intmax',...
    'spec cross density RMSE - intmax',...
    'dynamic krig MSE',...
    'dynamic krig RMSE',...
    'dynamic krig MSE (true dynamics)',...
    'dynamic krig RMSE (true dynamics)',...
    'transfer: threshold_value',...
    'transfer: threshold_value (rule)',...
    'transfer: RMSE',...
    'transfer: MSE',...
    'Z error train',...
    'Z error train (true dynamics)',...
    'Z error test',...
    'Z error test (true dynamics)',...
    'Z error train (holdout)',...
    'Z error train (holdout true dynamics)',...
    };


%%
commaHeader_tikhonov = [cHeader_tikhonov;repmat({','},1,numel(cHeader_tikhonov))]; %insert commaas
commaHeader_tikhonov = commaHeader_tikhonov(:)';
textHeader_tikhonov = cell2mat(commaHeader_tikhonov); %cHeader in text with commas
commaHeader_threshold_value = [cHeader_threshold_value;repmat({','},1,numel(cHeader_threshold_value))]; %insert commaas
commaHeader_threshold_value = commaHeader_threshold_value(:)';
textHeader_threshold_value = cell2mat(commaHeader_threshold_value); %cHeader in text with commas

if (~exist(fileName_tikhonov, 'file'))
    %write header to file
    fid = fopen(fileName_tikhonov,'w');
    fprintf(fid,'%s\n',textHeader_tikhonov);
    fclose(fid);
end

if (~exist(fileName_threshold_value, 'file'))
    %write header to file
    fid = fopen(fileName_threshold_value,'w');
    fprintf(fid,'%s\n',textHeader_threshold_value);
    fclose(fid);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
fileName_fullyfunctional_tikhonov = 'results/sim_fullyfunctional_tikhonov.csv';
fileName_fullyfunctional_threshold_value = 'results/sim_fullyfunctional_threshold_value.csv';

%% create the columns

cHeader_fullyfunctional_tikhonov = {...
    'simulated_process',...
    'response_process_shape',...
    'response_process',...    
    'seed',...
    'exec time'...    
    'T',...    
    'q_bartlett',...    
    'cov lag 0 RMSE',...
    'spec density MSE - FRO',...
    'spec density RMSE - FRO',...
    'spec density R2MSE - FRO',...
    'spec density MSE - intmax',...
    'spec density RMSE - intmax',...
    'spec density R2MSE - intmax',...
    'spec density MSE - maxmax',...
    'spec density RMSE - maxmax',...
    'spec cross density MSE - L2',...
    'spec cross density RMSE - L2',...
    'spec cross density MSE - intmax',...
    'spec cross density RMSE - intmax',...    
    'transfer: tikhonov parameter',...
    'transfer: RMSE',...
    'transfer: MSE',...
    'Z error train',...
    'Z error train (true dynamics)',...
    'Z error test',...
    'Z error test (true dynamics)',...
    'Z error train (holdout)',...
    'Z error train (holdout true dynamics)',...
    };
cHeader_fullyfunctional_threshold_value = {...
    'simulated_process',...
    'response_process_shape',...
    'response_process',...    
    'seed',...
    'exec time'...    
    'T',...    
    'q_bartlett',...    
    'cov lag 0 RMSE',...
    'spec density MSE - FRO',...
    'spec density RMSE - FRO',...
    'spec density R2MSE - FRO',...
    'spec density MSE - intmax',...
    'spec density RMSE - intmax',...
    'spec density R2MSE - intmax',...
    'spec density MSE - maxmax',...
    'spec density RMSE - maxmax',...
    'spec cross density MSE - L2',...
    'spec cross density RMSE - L2',...
    'spec cross density MSE - intmax',...
    'spec cross density RMSE - intmax',...    
    'transfer: truncation parameter',...
    'transfer: RMSE',...
    'transfer: MSE',...
    'Z error train',...
    'Z error train (true dynamics)',...
    'Z error test',...
    'Z error test (true dynamics)',...
    'Z error train (holdout)',...
    'Z error train (holdout true dynamics)',...
    };

%%
commaHeader_fullyfunctional_tikhonov = [cHeader_fullyfunctional_tikhonov;repmat({','},1,numel(cHeader_fullyfunctional_tikhonov))]; %insert commaas
commaHeader_fullyfunctional_tikhonov = commaHeader_fullyfunctional_tikhonov(:)';
textHeader_fullyfunctional_tikhonov = cell2mat(commaHeader_fullyfunctional_tikhonov); %cHeader in text with commas

commaHeader_fullyfunctional_threshold_value = [cHeader_fullyfunctional_threshold_value;repmat({','},1,numel(cHeader_fullyfunctional_threshold_value))]; %insert commaas
commaHeader_fullyfunctional_threshold_value = commaHeader_fullyfunctional_threshold_value(:)';
textHeader_fullyfunctional_threshold_value = cell2mat(commaHeader_fullyfunctional_threshold_value); %cHeader in text with commas

if (~exist(fileName_fullyfunctional_tikhonov, 'file'))
    %write header to file
    fid = fopen(fileName_fullyfunctional_tikhonov,'w');
    fprintf(fid,'%s\n',textHeader_fullyfunctional_tikhonov);
    fclose(fid);
end

if (~exist(fileName_fullyfunctional_threshold_value, 'file'))
    %write header to file
    fid = fopen(fileName_fullyfunctional_threshold_value,'w');
    fprintf(fid,'%s\n',textHeader_fullyfunctional_threshold_value);
    fclose(fid);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% prepare the onb.basis

% nGridSpace = 241, nKnots = 24
onb = fPrepareONB(241, 24);



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%                          SIMULATION STARTS HERE                     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%% random seed that has been saved
tic

[simulation_cases,~,~,~,~] = fPrepareSimulationCases();
nRandi_min = 0;
nGridTime = simulation_cases.nGridTime(iCase);
nRandi_max = simulation_cases.nRandi_max(iCase);


fprintf('#################################################################################\n')
fprintf('#################################################################################\n')
fprintf('\n')
fprintf('iCase = %d\n',iCase)
fprintf('seed = %d\n',initial_seed)
fprintf('nGridTime = %d\n',nGridTime)
fprintf('nRandi_max = %d\n',nRandi_max)
fprintf('simulated_process = %d\n',simulated_process)
fprintf('response_process_shape = %d\n',response_process_shape)
fprintf('response_process = %d\n',response_process)
fprintf('\n')
fprintf('#################################################################################\n')
fprintf('#################################################################################\n')



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% simulate the process - twice
nGridFreq = 1000;
dataFull_padding = 30;


if simulated_process <= 2
    % AR(1)
    [censor, dataFull, dataFullONB, dataFull_padded, dataFullONB_padded, covsLags_true, mu_true, specDensity_true, maxEigenvalue,sigma] = fSimulate_AR2020_v3(onb,simulated_process,nGridTime,nRandi_max,nRandi_min,nGridFreq,dataFull_padding);
    [censor_test, dataFull_test,dataFullONB_test,dataFull_test_padded,dataFullONB_test_padded,~,~,~,~,~] = fSimulate_AR2020_v3(onb,simulated_process,nGridTime,nRandi_max,nRandi_min,nGridFreq,dataFull_padding);
else
    % MA(q)
    [censor, dataFull, dataFullONB, dataFull_padded, dataFullONB_padded, covsLags_true, mu_true, specDensity_true, MA_order, sigma] = fSimulate_MA2020_v3(onb,simulated_process,nGridTime,nRandi_max,nRandi_min,nGridFreq,dataFull_padding);
    [censor_test, dataFull_test,dataFullONB_test,dataFull_test_padded,dataFullONB_test_padded,~,~,~,~,~] = fSimulate_MA2020_v3(onb,simulated_process,nGridTime,nRandi_max,nRandi_min,nGridFreq,dataFull_padding);
end



%% set up the response process

[response, response_wo_noise, transfer_true, specCrossDensity_true] = fSimulate_response_ONB_v3(onb,response_process,response_process_shape, dataFullONB_padded,dataFull_padding,specDensity_true);
[response_test,~,~,~] = fSimulate_response_ONB_v3(onb,response_process,response_process_shape,dataFullONB_test_padded,dataFull_padding,specDensity_true);



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                       select the tunning parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

bw_mu = 1;
mu_est_smoother = zeros(onb.nGridSmoother,1);

mu_est_ONB = onb.smoothingMatrix_gridSmoother2ONB * mu_est_smoother;
mu_est_inSpace = onb.onbMatrix*mu_est_ONB;



%%    K-FOLD CV for the surface smoothing

[bw_r, bw_v, covLag0_smoother, covLag0_ridge_smoother, sigma2_est_loc_qv, sigma2_est_loc_lin] = fKCVforR_locQv(censor,onb,mu_est_inSpace);

covLag0_ONB = onb.smoothingMatrix_gridSmoother2ONB * covLag0_smoother * onb.smoothingMatrix_gridSmoother2ONB';
covLag0_inSpace = onb.onbMatrix * covLag0_ONB * onb.onbMatrix';



%%  K-FOLD CV for the cross-spectral density
[bw_c, crossCov0_smoother] = fKCVforCrossR(censor,onb,response,mu_est_inSpace);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%           estimate the spectral density and quantify the estimation error
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% estimate the spectral density
bw_F = bw_r; % the same smoothing parameter as for cov lag 0
specDensity_v7 = fEstimateSpecDensity_v7_2020(censor,onb,mu_est_inSpace,bw_F,nGridFreq);



%% visualise the bias

spd7_bias = zeros(specDensity_v7.nGridFreq,1);


for k = 1:specDensity_v7.nGridFreq    
    m_spc7 = onb.onbMatrix * squeeze( specDensity_v7.ONB(k,:,:) ) * onb.onbMatrix';
    m_true = onb.onbMatrix * squeeze( specDensity_true.ONB(k,:,:) ) * onb.onbMatrix';    
    mm7 = m_spc7 - m_true;
    spd7_bias(k) = sum( mm7(:) );    
end

v7_bias_norm = mean( abs(spd7_bias).^2 );

%% quantify the error of spec density estimation
v7_specDensity_error = fSpecDensityError( onb, specDensity_v7, specDensity_true );






%% visualize the bias

spd7_bias = zeros(specDensity_v7.nGridFreq,1);

for k = 1:specDensity_v7.nGridFreq
    
    m_spc7 = onb.onbMatrix * squeeze( specDensity_v7.ONB(k,:,:) ) * onb.onbMatrix';
    m_true = onb.onbMatrix * squeeze( specDensity_true.ONB(k,:,:) ) * onb.onbMatrix';    
    
    mm7 = m_spc7 - m_true;
    spd7_bias(k) = sum( mm7(:) );
    
end


%% extract auto-covariances (integrate out the spectral density)
numOfLags_all = censor.nGridTime - 1;
% f212_covLags = fEstimateCovLags(onb,f212_specDensity,numOfLags_all);
v7_covLags = fEstimateCovLags(onb,specDensity_v7,numOfLags_all);

%% quantify the error of cov lag 0 estimation
covLag0_error = fCovLag0Error( onb, covsLags_true, covLag0_ONB );
% covLag0_error.mse
% covLag0_error.rmse

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%     kriging for the process X

% if I want to get confidence bands
cofidence_bands = 0;

% use the sigma from the loc-qv estimation
s2 = sigma2_est_loc_qv;
if s2 < 1e-2, s2 = 1e-2; end
sigma_est = sqrt( s2 );


% kriging on the TRAINING sample
disp('kriging 1./4')
[krigingX_dyna,krigingX_dyna_padded] = fKrigingX( censor, onb, v7_covLags, mu_est_ONB, sigma_est, 1, cofidence_bands, dataFull_padding );
disp('kriging 2./4')
[krigingX_dyna_true,krigingX_dyna_padded_true] = fKrigingX( censor, onb, covsLags_true, mu_true, sigma, 1, cofidence_bands, dataFull_padding );

% kriging on the TEST sample
disp('kriging 3./4')
[krigingX_dyna_test,krigingX_dyna_test_padded] = fKrigingX( censor_test, onb, v7_covLags, mu_est_ONB, sigma_est, 1, cofidence_bands, dataFull_padding );
disp('kriging 4./4')
[krigingX_dyna_test_true,krigingX_dyna_test_padded_true] = fKrigingX( censor_test, onb, covsLags_true, mu_true, sigma, 1, cofidence_bands, dataFull_padding );


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   quantify the kriging error

krigingX_dyna_error = fKrigingX_error( onb, dataFull, krigingX_dyna, covsLags_true.lag0, cofidence_bands );
krigingX_dyna_error_true = fKrigingX_error( onb, dataFull, krigingX_dyna_true, covsLags_true.lag0, cofidence_bands );


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%           estimate the CROSS-spectral density
disp('cross spectral density')
response_mean = 0;
specCrossDensity = fEstimateSpecCrossDensity_holdout_v5(censor,onb,response,response_mean,mu_est_inSpace,bw_c,nGridFreq,holdout); % bandwidth: bw_c

specCrossDensity_error = fSpecCrossDensityError( onb, specCrossDensity, specCrossDensity_true );


%%

exectime = toc;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   truncation CV
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% holdout cross-validation to determine the threshold
threshold_value_interval = [0.0001, 100];
[threshold_value] = fHoldoutCVforTransfer_trunc(threshold_value_interval, censor, onb, holdout, specDensity_v7, specCrossDensity, krigingX_dyna_padded, response, dataFull_padding);
threshold_value_string = 'holdout CV';

%% fit the transfer functions
transfer = fEstimateTransfer_threshold_value(onb,specDensity_v7,specCrossDensity, threshold_value);        

% quantify the error of transfer functionals
[transfer_rmse, transfer_mse] = fTransferError_v2(transfer,transfer_true);


% estimation on the TRAINING sample
response_est = fKrigingZ(krigingX_dyna_padded,transfer,dataFull_padding);
response_est_true = fKrigingZ(krigingX_dyna_padded_true,transfer_true,dataFull_padding);

% estimation on the TEST sample
response_est_test = fKrigingZ(krigingX_dyna_test_padded,transfer,dataFull_padding);
response_est_test_true = fKrigingZ(krigingX_dyna_test_padded_true,transfer_true,dataFull_padding);

% calculate var(Z) for normalization
var_z = 0;
for kk = 1:(2*transfer_true.numOfLags-1)
    for ll = 1:(2*transfer_true.numOfLags-1)
        lag = kk-ll;
        if lag >= 0, C = squeeze(covsLags_true.ONB(lag+1,:,:));
        else, C = squeeze(covsLags_true.ONB(-lag+1,:,:))'; end
        var_z = var_z + transfer_true.ONB(kk,:)*C*transfer_true.ONB(ll,:)';
    end
end

% quantify errors
Z_est_error = fKrigingZ_error( response_est, response', var_z );
Z_est_true_error = fKrigingZ_error( response_est_true, response', var_z );
Z_est_test_error = fKrigingZ_error( response_est_test, response_test', var_z );
Z_est_test_true_error = fKrigingZ_error( response_est_test_true, response_test', var_z );
Z_est_holdout_error = fKrigingZ_holdout_error( response_est, response', var_z, holdout);
Z_est_holdout_true_error = fKrigingZ_holdout_error( response_est_true, response', var_z, holdout );




%% save results


results = {...
    num2str( simulated_process ),...
    num2str( response_process_shape ),...
    num2str( response_process ),...
    num2str( iCase ),...
    num2str( initial_seed ),...
    num2str( exectime ),...
    num2str( censor.cv_K ),...
    num2str( censor.nGridTime ),...
    num2str( sum(censor.nGrid) ),...
    num2str( sum(censor.nGrid)/nGridTime ),...
    num2str( bw_mu ),...
    num2str( bw_F ),...
    num2str( bw_v ),...
    num2str( specDensity_v7.q_bartlett ),...
    num2str( specCrossDensity.q_bartlett ),...
    num2str( v7_covLags.cutOfLag ),...
    num2str( nRandi_max ),...
    num2str( sigma^2 ),...
    num2str( sigma2_est_loc_lin ),...
    num2str( sigma2_est_loc_qv ),...
    num2str( covLag0_error.mse ),...
    num2str( covLag0_error.rmse ),...
    num2str( v7_specDensity_error.mse_fro ),...
    num2str( v7_specDensity_error.rmse_fro ),...
    num2str( v7_specDensity_error.r2mse_fro ),...
    num2str( v7_specDensity_error.mse_intmax ),...
    num2str( v7_specDensity_error.rmse_intmax ),...
    num2str( v7_specDensity_error.r2mse_intmax ),...
    num2str( v7_specDensity_error.mse_maxmax ),...
    num2str( v7_specDensity_error.rmse_maxmax ),...
    num2str( v7_bias_norm ),...
    num2str( specCrossDensity_error.mse_qv ),...
    num2str( specCrossDensity_error.rmse_qv ),...
    num2str( specCrossDensity_error.mse_intmax ),...
    num2str( specCrossDensity_error.rmse_intmax ),...
    num2str( krigingX_dyna_error.mse ),...
    num2str( krigingX_dyna_error.rmse ),...
    num2str( krigingX_dyna_error_true.mse ),...
    num2str( krigingX_dyna_error_true.rmse ),...
    num2str( threshold_value ),...
    threshold_value_string,...
    num2str( transfer_rmse ),...
    num2str( transfer_mse ),...
    num2str( Z_est_error ),...
    num2str( Z_est_true_error ),...
    num2str( Z_est_test_error ),...
    num2str( Z_est_test_true_error ),...
    num2str( Z_est_holdout_error ),...
    num2str( Z_est_holdout_true_error )...
    };

% write the results into CSV
commaResults = [results;repmat({','},1,numel(results))]; %insert commaas
commaResults = commaResults(:)';
textResults = cell2mat(commaResults); %cHeader in text with commas

% write into one file
fid = fopen(fileName_threshold_value,'a');
fprintf(fid,'%s\n',textResults);
fclose(fid);



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%           Tikhonov regularization
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% holdout cross-validation to determine the threshold
tikhonovParameter_interval = [0.0001, 10];
[tikhonovParameter] = fHoldoutCVforTransfer_Tikh(tikhonovParameter_interval, censor, onb, holdout, specDensity_v7, specCrossDensity, krigingX_dyna_padded, response, dataFull_padding);
tikhonovParameter_string = 'holdout CV';

%% fit the transfer functions
transfer = fEstimateTransfer_Tikhonov(onb,specDensity_v7,specCrossDensity, tikhonovParameter);

% quantify the error of transfer functionals
[transfer_rmse, transfer_mse] = fTransferError_v2(transfer,transfer_true);






%%

% estimate the response process

% estimation on the TRAINING sample
response_est = fKrigingZ(krigingX_dyna_padded,transfer,dataFull_padding);
response_est_true = fKrigingZ(krigingX_dyna_padded_true,transfer_true,dataFull_padding);

% estimation on the TEST sample
response_est_test = fKrigingZ(krigingX_dyna_test_padded,transfer,dataFull_padding);
response_est_test_true = fKrigingZ(krigingX_dyna_test_padded_true,transfer_true,dataFull_padding);


% calculate var(Z) for normalization
var_z = 0;
for kk = 1:(2*transfer_true.numOfLags-1)
    for ll = 1:(2*transfer_true.numOfLags-1)
        lag = kk-ll;
        if lag >= 0, C = squeeze(covsLags_true.ONB(lag+1,:,:));
        else, C = squeeze(covsLags_true.ONB(-lag+1,:,:))'; end
        var_z = var_z + transfer_true.ONB(kk,:)*C*transfer_true.ONB(ll,:)';
    end
end

% quantify errors
Z_est_error = fKrigingZ_error( response_est, response', var_z );
Z_est_true_error = fKrigingZ_error( response_est_true, response', var_z );
Z_est_test_error = fKrigingZ_error( response_est_test, response_test', var_z );
Z_est_test_true_error = fKrigingZ_error( response_est_test_true, response_test', var_z );
Z_est_holdout_error = fKrigingZ_holdout_error( response_est, response', var_z, holdout);
Z_est_holdout_true_error = fKrigingZ_holdout_error( response_est_true, response', var_z, holdout );



%% save results
results = {...
    num2str( simulated_process ),...
    num2str( response_process_shape ),...
    num2str( response_process ),...
    num2str( iCase ),...
    num2str( initial_seed ),...
    num2str( exectime ),...
    num2str( censor.cv_K ),...
    num2str( censor.nGridTime ),...
    num2str( sum(censor.nGrid) ),...
    num2str( sum(censor.nGrid)/nGridTime ),...
    num2str( bw_mu ),...
    num2str( bw_F ),...
    num2str( bw_v ),...
    num2str( specDensity_v7.q_bartlett ),...
    num2str( specCrossDensity.q_bartlett ),...
    num2str( v7_covLags.cutOfLag ),...
    num2str( nRandi_max ),...
    num2str( sigma^2 ),...
    num2str( sigma2_est_loc_lin ),...
    num2str( sigma2_est_loc_qv ),...
    num2str( covLag0_error.mse ),...
    num2str( covLag0_error.rmse ),...
    num2str( v7_specDensity_error.mse_fro ),...
    num2str( v7_specDensity_error.rmse_fro ),...
    num2str( v7_specDensity_error.r2mse_fro ),...
    num2str( v7_specDensity_error.mse_intmax ),...
    num2str( v7_specDensity_error.rmse_intmax ),...
    num2str( v7_specDensity_error.r2mse_intmax ),...
    num2str( v7_specDensity_error.mse_maxmax ),...
    num2str( v7_specDensity_error.rmse_maxmax ),...
    num2str( v7_bias_norm ),...
    num2str( specCrossDensity_error.mse_qv ),...
    num2str( specCrossDensity_error.rmse_qv ),...
    num2str( specCrossDensity_error.mse_intmax ),...
    num2str( specCrossDensity_error.rmse_intmax ),...
    num2str( krigingX_dyna_error.mse ),...
    num2str( krigingX_dyna_error.rmse ),...
    num2str( krigingX_dyna_error_true.mse ),...
    num2str( krigingX_dyna_error_true.rmse ),...
    num2str( tikhonovParameter ),...
    tikhonovParameter_string,...
    num2str( transfer_rmse ),...
    num2str( transfer_mse ),...
    num2str( Z_est_error ),...
    num2str( Z_est_true_error ),...
    num2str( Z_est_test_error ),...
    num2str( Z_est_test_true_error ),...
    num2str( Z_est_holdout_error ),...
    num2str( Z_est_holdout_true_error )...
    };

% write the results into CSV
commaResults = [results;repmat({','},1,numel(results))]; %insert commaas
commaResults = commaResults(:)';
textResults = cell2mat(commaResults); %cHeader in text with commas

% write into one file
fid = fopen(fileName_tikhonov,'a');
fprintf(fid,'%s\n',textResults);
fclose(fid);



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              fully functional case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tic


% mind the fact that the crosscov is done only without holdout
% holdout = percentage of how much data at the end of the response process is not used for the training
% typically, holdout = 0.8
holdout_number = floor(censor.nGridTime * holdout); % the number of points in the holdout partition
holdout_start = censor.nGridTime - holdout_number + 1; % the index of the first datum in the holdout partition

% prepare the estimates of the autocovariance operators
num_of_lags = nGridTime;
cov_estim = nan(num_of_lags,onb.nBasis,onb.nBasis);
crosscov_estim = nan(num_of_lags,onb.nBasis);
crosscov_estim_minus_lags = nan(num_of_lags,onb.nBasis);
for lag_real = 0:(num_of_lags-1)
    lag_index = lag_real + 1;
    
    cov_estim(lag_index,:,:) = 1/(nGridTime - lag_real) * dataFullONB( (lag_real+1):nGridTime ,:)' * dataFullONB( 1:(nGridTime-lag_real) ,:);
    crosscov_estim(lag_index,:) = 1/((holdout_start-1) - lag_real) * response( (lag_real+1):(holdout_start-1))' * dataFullONB( 1:((holdout_start-1)-lag_real) ,:);
    crosscov_estim_minus_lags(lag_index,:) = 1/((holdout_start-1) - lag_real) * response( 1:((holdout_start-1)-lag_real) )' * dataFullONB( (lag_real+1):(holdout_start-1) ,:);
end



%% quantify the error of cov lag 0 estimation
covLag0_error = fCovLag0Error( onb, covsLags_true, squeeze(cov_estim(1,:,:)) );


%% estimate the spectral density
nGridFreq = 1000;
specDensity = [];
specDensity.nGridFreq = nGridFreq;
specDensity.gridFreq = linspace(-pi,pi,specDensity.nGridFreq);
q_bartlett = floor(sqrt(nGridTime));
specDensity.q_bartlett = q_bartlett;
specDensity.ONB = nan(nGridFreq, onb.nBasis, onb.nBasis);

specCrossDensity = [];
specCrossDensity.nGridFreq = nGridFreq;
specCrossDensity.gridFreq = linspace(-pi,pi, specCrossDensity.nGridFreq);
specCrossDensity.ONB = nan(specCrossDensity.nGridFreq, onb.nBasis);
specCrossDensity.q_bartlett = q_bartlett;

for k = 1:nGridFreq    
    omega = specDensity.gridFreq(k);
    % zero lag
    specDensity.ONB(k,:,:) = 1/(2*pi)*squeeze(cov_estim(1,:,:));
    specCrossDensity.ONB(k,:) = 1/(2*pi)*crosscov_estim(1,:);
    % non-zero lags
    for lag_real = 1:(q_bartlett-1)
        lag_index = lag_real + 1;
        specDensity.ONB(k,:,:) = squeeze(specDensity.ONB(k,:,:)) +... % positive lag
            1/(2*pi)*(1 - lag_real/q_bartlett)*squeeze(cov_estim(lag_index,:,:)) * exp(-1i*omega*lag_real);
        specDensity.ONB(k,:,:) = squeeze(specDensity.ONB(k,:,:)) +... % negative lag => transpose the autocovariance
            1/(2*pi)*(1 - lag_real/q_bartlett)*squeeze(cov_estim(lag_index,:,:))' * exp(+1i*omega*lag_real);
        specCrossDensity.ONB(k,:) = specCrossDensity.ONB(k,:) +...
            1/(2*pi)*(1 - lag_real/q_bartlett)*crosscov_estim(lag_index,:) * exp(-1i*omega*lag_real);
        specCrossDensity.ONB(k,:) = specCrossDensity.ONB(k,:) +...
            1/(2*pi)*(1 - lag_real/q_bartlett)*crosscov_estim_minus_lags(lag_index,:) * exp(+1i*omega*lag_real);
    end
    
end

response_mean = 0;
%% quantify the error of spec density and cross-spectral density
specDensity_error = fSpecDensityError( onb, specDensity, specDensity_true );
specCrossDensity_error = fSpecCrossDensityError( onb, specCrossDensity, specCrossDensity_true );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Tikhonov regularization


% here I'm padding with zeroes because that's what Hoermann does
dataFullONB_padded_w_zeros=[];
dataFullONB_padded_w_zeros.est = [zeros(dataFull_padding,onb.nBasis); dataFullONB; zeros(dataFull_padding,onb.nBasis)];
dataFullONB_test_padded_w_zeros=[];
dataFullONB_test_padded_w_zeros.est = [zeros(dataFull_padding,onb.nBasis); dataFullONB_test; zeros(dataFull_padding,onb.nBasis)];


% holdout cross-validation to determine the threshold
tikhonovParameter_interval = [0.00001, 0.1];
[tikhonovParameter] = fHoldoutCVforTransfer_Tikh(tikhonovParameter_interval, censor, onb, holdout, specDensity,specCrossDensity, dataFullONB_padded_w_zeros, response, dataFull_padding);


%% fit the transfer functions
transfer = fEstimateTransfer_Tikhonov(onb,specDensity,specCrossDensity, tikhonovParameter);

% quantify the error of transfer functionals
[transfer_rmse, transfer_mse] = fTransferError_v2(transfer,transfer_true);



%%

% estimate the response process

% estimation on the TRAINING sample
response_est = fKrigingZ(dataFullONB_padded_w_zeros,transfer,dataFull_padding);
response_est_true = fKrigingZ(dataFullONB_padded_w_zeros,transfer_true,dataFull_padding);

% estimation on the TEST sample
response_est_test = fKrigingZ(dataFullONB_test_padded_w_zeros,transfer,dataFull_padding);
response_est_test_true = fKrigingZ(dataFullONB_test_padded_w_zeros,transfer_true,dataFull_padding);

% calculate var(Z) for normalization
var_z = 0;
for kk = 1:(2*transfer_true.numOfLags-1)
    for ll = 1:(2*transfer_true.numOfLags-1)
        lag = kk-ll;
        if lag >= 0
            C = squeeze(covsLags_true.ONB(lag+1,:,:));
        else
            C = squeeze(covsLags_true.ONB(-lag+1,:,:))';
        end
        var_z = var_z + transfer_true.ONB(kk,:)*C*transfer_true.ONB(ll,:)';
    end
end

% quantify errors
Z_est_error = fKrigingZ_error( response_est, response', var_z );
Z_est_true_error = fKrigingZ_error( response_est_true, response', var_z );
Z_est_test_error = fKrigingZ_error( response_est_test, response_test', var_z );
Z_est_test_true_error = fKrigingZ_error( response_est_test_true, response_test', var_z );
Z_est_holdout_error = fKrigingZ_holdout_error( response_est, response', var_z, holdout);
Z_est_holdout_true_error = fKrigingZ_holdout_error( response_est_true, response', var_z, holdout );


exectime = toc;

results = {...
    num2str( simulated_process ),...
    num2str( response_process_shape ),...
    num2str( response_process ),...
    num2str( initial_seed ),...
    num2str( exectime ),...
    num2str( censor.nGridTime ),...
    num2str( specDensity.q_bartlett ),...
    num2str( covLag0_error.rmse ),...
    num2str( specDensity_error.mse_fro ),...
    num2str( specDensity_error.rmse_fro ),...
    num2str( specDensity_error.r2mse_fro ),...
    num2str( specDensity_error.mse_intmax ),...
    num2str( specDensity_error.rmse_intmax ),...
    num2str( specDensity_error.r2mse_intmax ),...
    num2str( specDensity_error.mse_maxmax ),...
    num2str( specDensity_error.rmse_maxmax ),...
    num2str( specCrossDensity_error.mse_qv ),...
    num2str( specCrossDensity_error.rmse_qv ),...
    num2str( specCrossDensity_error.mse_intmax ),...
    num2str( specCrossDensity_error.rmse_intmax ),...
    num2str( tikhonovParameter ),...
    num2str( transfer_rmse ),...
    num2str( transfer_mse ),...
    num2str( Z_est_error ),...
    num2str( Z_est_true_error ),...
    num2str( Z_est_test_error ),...
    num2str( Z_est_test_true_error ),...
    num2str( Z_est_holdout_error ),...
    num2str( Z_est_holdout_true_error )...
    };

% write the results into CSV
commaResults = [results;repmat({','},1,numel(results))]; %insert commaas
commaResults = commaResults(:)';
textResults = cell2mat(commaResults); %cHeader in text with commas


% write into one file
fid = fopen(fileName_fullyfunctional_tikhonov,'a');
fprintf(fid,'%s\n',textResults);
fclose(fid);



    


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Truncation regularization - varying over frequencies



% holdout cross-validation to determine the threshold
threshold_value_interval = [0.00001, 0.1];
[threshold_value] = fHoldoutCVforTransfer_trunc(threshold_value_interval, censor, onb, holdout, specDensity, specCrossDensity, dataFullONB_padded_w_zeros, response, dataFull_padding);


%% fit the transfer functions
transfer = fEstimateTransfer_threshold_value(onb,specDensity,specCrossDensity, threshold_value);

% quantify the error of transfer functionals
[transfer_rmse, transfer_mse] = fTransferError_v2(transfer,transfer_true);


% estimation on the TRAINING sample
response_est = fKrigingZ(dataFullONB_padded_w_zeros,transfer,dataFull_padding);
response_est_true = fKrigingZ(dataFullONB_padded_w_zeros,transfer_true,dataFull_padding);

% estimation on the TEST sample
response_est_test = fKrigingZ(dataFullONB_test_padded_w_zeros,transfer,dataFull_padding);
response_est_test_true = fKrigingZ(dataFullONB_test_padded_w_zeros,transfer_true,dataFull_padding);

% calculate var(Z) for normalization
var_z = 0;
for kk = 1:(2*transfer_true.numOfLags-1)
    for ll = 1:(2*transfer_true.numOfLags-1)
        lag = kk-ll;
        if lag >= 0, C = squeeze(covsLags_true.ONB(lag+1,:,:));
        else, C = squeeze(covsLags_true.ONB(-lag+1,:,:))'; end
        var_z = var_z + transfer_true.ONB(kk,:)*C*transfer_true.ONB(ll,:)';
    end
end

% quantify errors
Z_est_error = fKrigingZ_error( response_est, response', var_z );
Z_est_true_error = fKrigingZ_error( response_est_true, response', var_z );
Z_est_test_error = fKrigingZ_error( response_est_test, response_test', var_z );
Z_est_test_true_error = fKrigingZ_error( response_est_test_true, response_test', var_z );
Z_est_holdout_error = fKrigingZ_holdout_error( response_est, response', var_z, holdout);
Z_est_holdout_true_error = fKrigingZ_holdout_error( response_est_true, response', var_z, holdout );




%% save results
results = {...
    num2str( simulated_process ),...
    num2str( response_process_shape ),...
    num2str( response_process ),...
    num2str( initial_seed ),...
    num2str( exectime ),...
    num2str( censor.nGridTime ),...
    num2str( specDensity.q_bartlett ),...
    num2str( covLag0_error.rmse ),...
    num2str( specDensity_error.mse_fro ),...
    num2str( specDensity_error.rmse_fro ),...
    num2str( specDensity_error.r2mse_fro ),...
    num2str( specDensity_error.mse_intmax ),...
    num2str( specDensity_error.rmse_intmax ),...
    num2str( specDensity_error.r2mse_intmax ),...
    num2str( specDensity_error.mse_maxmax ),...
    num2str( specDensity_error.rmse_maxmax ),...
    num2str( specCrossDensity_error.mse_qv ),...
    num2str( specCrossDensity_error.rmse_qv ),...
    num2str( specCrossDensity_error.mse_intmax ),...
    num2str( specCrossDensity_error.rmse_intmax ),...
    num2str( threshold_value_interval ),...
    num2str( transfer_rmse ),...
    num2str( transfer_mse ),...
    num2str( Z_est_error ),...
    num2str( Z_est_true_error ),...
    num2str( Z_est_test_error ),...
    num2str( Z_est_test_true_error ),...
    num2str( Z_est_holdout_error ),...
    num2str( Z_est_holdout_true_error )...
    };

% write the results into CSV
commaResults = [results;repmat({','},1,numel(results))]; %insert commaas
commaResults = commaResults(:)';
textResults = cell2mat(commaResults); %cHeader in text with commas


% write into one file
fid = fopen(fileName_fullyfunctional_threshold_value,'a');
fprintf(fid,'%s\n',textResults);
fclose(fid);
